<?php
use Drupal\image\Entity\ImageStyle;
use Drupal\Core\Entity\FieldableEntityInterface;
use Kint\Kint;
use Drupal\Core\Render\Markup;
use Drupal\Core\Session\AccountInterface;

function react_components_theme($existing, $type, $theme, $path) {
  $module_path = \Drupal::service('extension.list.module')->getPath('react_components');

  return [
    'react_block' => [
      'render element' => 'content',
      'template' => 'react-block', // Maps to your-custom-block.html.twig
      'path' => $module_path . '/templates',
      'variables' => [
        'uuid' => '',
      ],
    ],
    'react_graphs_block' => [
      'base hook' => 'block',
      'render element' => 'elements',
      'template' => 'react-graphs-block',
      'path' => $module_path . '/templates',
      'variables' => [
        'uuid' => '',
      ],
    ],
    'paragraph__react_component' => [
      'render element' => 'elements',
      'path' => $module_path . '/templates',
      'template' => 'paragraph--react-component',
    ],
  ];
}

function react_components_preprocess_paragraph__react_component(array &$variables) {
  $paragraph = $variables['elements']['#paragraph'];
  $uuid = $paragraph->uuid();

  $settingsKey = 'rc-paragraph-' . $uuid;

  $variables['#attached']['drupalSettings']['reactComponents'][$settingsKey] = [
    'paragraph_uuid' => $uuid,
    'componentType' => $paragraph->get('field_component_type')->value,
    'title' => $paragraph->get('field_component_title')->value
  ];

  $variables['uuid'] = $uuid;
  $variables['#attached']['library'][] = 'react_components/react-components-lib';
  $component_type = $paragraph->get('field_component_type')->value;

  if ($component_type == "image_and_text") {
    $moreSettings = [];

    $moreSettings['long_text'] = $paragraph->get('field_long_text')->processed;
    $moreSettings['alignment'] = $paragraph->get('field_right_or_left')->value;

    if ($paragraph->hasField('field_single_image') && !$paragraph->get('field_single_image')->isEmpty()) {
      $media_field = $paragraph->get('field_single_image');
      $media_entity = $media_field->entity;

      $media_source = $media_entity->getSource();
      $source_field = $media_source->getSourceFieldDefinition($media_entity->bundle->entity);
      $source_field_name = $source_field->getName();
      
      $image_field = $media_entity->get($source_field_name);

      $file_entity = $image_field->entity;

      $image_style = ImageStyle::load('large');
      $large_style_url = $image_style->buildUrl($file_entity->getFileUri());
      
      $origonal_file_url = \Drupal::service('file_url_generator')->generateAbsoluteString($file_entity->getFileUri());

      // Convert URI to real system path
      $file_system = \Drupal::service('file_system');
      // the problme with $origional file url is that it's the full thing 
      // while this function wants public://.. so gott use $file_entity->getFileUri()
      $real_path = $file_system->realpath($file_entity->getFileUri());

      // Use now image factory to get dimensions
      $image_factory = \Drupal::service('image.factory');
      $image = $image_factory->get($real_path);

      $moreSettings["image_alt"] = $image_field->alt;
      $moreSettings["large_style_url"] = $large_style_url;
      $moreSettings["origonal_file_url"] = $origonal_file_url;
      $moreSettings["picture_id"] = $media_entity->id();
      $moreSettings['image_width'] = $image->getWidth();
      $moreSettings['image_height'] = $image->getHeight();

    }

    // $moreSettings["paragraph_type"] = "image_and_text";
    $finalSettings = array_merge($variables['#attached']['drupalSettings']['reactComponents'][$settingsKey], $moreSettings);
    $variables['#attached']['drupalSettings']['reactComponents'][$settingsKey] = $finalSettings;

  } else if ($component_type == "image_gallery") {
    $moreSettings = ['img_arr' => []];

    $media_items = $paragraph->get('field_gallery_images')->referencedEntities();

    // kint($media_items);
    $image_factory = \Drupal::service('image.factory');

    // more succinct the 2nd time around
    foreach ($media_items as $media) {
      $image_vars = [];
      if ($media->hasField('field_media_image') && !$media->get('field_media_image')->isEmpty()) {
        $image_field = $media->get('field_media_image');
        $file = $image_field->entity;
        $file_system = \Drupal::service('file_system');

        if ($file) {
          $file_uri = $file->getFileUri();
          $image_style = ImageStyle::load('large');
          $origonal_file_url = \Drupal::service('file_url_generator')->generateAbsoluteString($file_uri);
          $large_style_url = $image_style->buildUrl($file_uri);
          $real_path = $file_system->realpath($file->getFileUri());
          $image = $image_factory->get($real_path);

          $image_vars["picture_id"] = $media->id();
          $image_vars["image_alt"] = $image_field->alt;
          $image_vars["origonal_file_url"] = $origonal_file_url;
          $image_vars["large_style_url"] = $large_style_url;
          $image_vars['image_width'] = $image->getWidth();
          $image_vars['image_height'] = $image->getHeight(); 

          $moreSettings['img_arr'][] = $image_vars;
        }
      }
    }

    $finalSettings = array_merge($variables['#attached']['drupalSettings']['reactComponents'][$settingsKey], $moreSettings);
    $variables['#attached']['drupalSettings']['reactComponents'][$settingsKey] = $finalSettings;
  }
}


// let's give the block a custom id based on the title
function react_components_preprocess_block(&$variables) {
  $plugin_id = $variables['elements']['#plugin_id'];

  if ($plugin_id == 'react_block') {

    if (!empty($variables['configuration']['component_title'])) {
      $title = $variables['configuration']['component_title'];
      $id = strtolower($title);
      $id = trim($id);
      $id = preg_replace('/[^a-z0-9]+/', '-', $id);
      $id = 'rcb-' . $id;
      $variables['attributes']['id']  = $id;
    }

    $uuid = $variables['elements']['content']['react_block']['#uuid'];
    $settingsKey = 'rc-block-' . $uuid;

    // send the html of the menus as variables to this component
    // first, use the simplest way of loading a generic menu correctlly, and load 'main'
    if ($variables['configuration']['component_type'] == "slideout_menu") {
      $menu_name = 'main';

      $menu_tree = \Drupal::menuTree();

      // $menu_storage = \Drupal::entityTypeManager()->getStorage('menu');
      // $menu = $menu_storage->load($menu_name);

      $parameters = $menu_tree->getCurrentRouteMenuTreeParameters($menu_name);
      $tree = $menu_tree->load($menu_name, $parameters);

      $manipulators = [
        ['callable' => 'menu.default_tree_manipulators:checkAccess'],
        ['callable' => 'menu.default_tree_manipulators:generateIndexAndSort'],
      ];

      $tree = $menu_tree->transform($tree, $manipulators);

      // Build render array
      $menu_build = $menu_tree->build($tree);
      $menu_build['#theme'] = 'menu__mobile_main_slideout';
      
      // Render to HTML
      $renderer = \Drupal::service('renderer');
      $menu_html = $renderer->render($menu_build);

      // Ok, I aslo wanna send the system brandings block to the frontend
      $site_branding_block = \Drupal::entityTypeManager()
        ->getStorage('block')
        ->load('weightvest_running_site_branding');
      
      $site_branding_block_content = \Drupal::entityTypeManager()
        ->getViewBuilder('block')
        ->view($site_branding_block);

      $branding_html = $renderer->render($site_branding_block_content);

      // the build() function gives blocks a uuid .. 
      // $uuid = $variables['elements']['content']['react_block']['#uuid'];
      // $settingsKey = 'rc-block-' . $uuid;

      // ok menu html lookd good. Now to load it to settings.. 
      $moreSettings = [
        "blockType" => "slideout_menu",
        "menuHtml" =>  $menu_html,
        "brandingHtml" => $branding_html
      ];

      $finalSettings = array_merge($variables['content']['react_block']['#attached']['drupalSettings']['reactComponents'][$settingsKey], $moreSettings);
      $variables['content']['react_block']['#attached']['drupalSettings']['reactComponents'][$settingsKey] = $finalSettings;

      // alright the rest should be taken care of on the frontend
    } else if ($variables['configuration']['component_type'] == "fitness_metrics_page_block") {
      // get the fields from the node

      $node = \Drupal::routeMatch()->getParameter('node');

      if ($node && $node->getType() == 'fitness_metrics') {

        $moreSettings = [];

        $field_mappings = [
          'field_40_full_circuit_weight' => 'full_circuit_weight',
          'field_40_goblet_squat_weight' => 'goblet_squat_weight', 
          'field_40_lunge_weight' => 'lunge_weight',
          'field_40_pushup_weight' => 'pushup_weight',
          'field_number_of_pullups' => 'number_of_pullups'
        ];

        $decimal_fields = [
          'field_40_full_circuit_weight',
          'field_40_goblet_squat_weight',
          'field_40_lunge_weight', 
          'field_40_pushup_weight'
        ];

        foreach ($field_mappings as $field_name => $variable_name) {
          if ($node->hasField($field_name) && !$node->get($field_name)->isEmpty()) {
            $value = $node->get($field_name)->value;

            // Round decimal fields to 2 places
            if (in_array($field_name, $decimal_fields)) {
              $value = round($value, 2);
            }

            $moreSettings[$variable_name] = $value;
          } else {
            $moreSettings[$variable_name] = null;
          }
        }

        // also let's get the config values from health_metrics
        $site_config = \Drupal::config('system.site');

        $moreSettings['exercise_max_weight'] = $site_config->get('excersize_max_weight'); // whoops spelled thsi wrong in config oh well
        $moreSettings['max_pullups'] = $site_config->get('max_pullups'); 
        $moreSettings["blockType"] = "fitness_metrics_page_block";
        $moreSettings['title'] = $node->getTitle();

        // ugh this is ugly can't remember how this was set up if it can be made cleaner haha
        $finalSettings = array_merge($variables['content']['react_block']['#attached']['drupalSettings']['reactComponents'][$settingsKey], $moreSettings);
        $variables['content']['react_block']['#attached']['drupalSettings']['reactComponents'][$settingsKey] = $finalSettings;
      } 
    } else if ($variables['configuration']['component_type'] == "results_graphs") {

      $entity_storage = \Drupal::entityTypeManager()->getStorage('daily_log');
      $config = \Drupal::config("health_metrics.settings");

      $display_mode = $config->get('display_mode');
      $interval = intval($config->get('interval'));
      
      if ($display_mode == 'number') {

        $num_of_entries = $config->get('number_of_entries');
        $metric_query = $entity_storage->getQuery()
          ->condition('type', 'health_metric') // assuming 'type' is the bundle field
          ->accessCheck(TRUE) // security
          ->sort('created', 'DESC')
          ->range(0, $num_of_entries); // Get num_of_entries items starting from position 0; // sort by creation date

        $diet_query = $entity_storage->getQuery()
          ->condition('type', 'diet_entry') 
          ->accessCheck(TRUE) 
          ->sort('created', 'DESC')
          ->range(0, $num_of_entries); 
        
        $workout_query = $entity_storage->getQuery()
          ->condition('type', 'running_workout') 
          ->accessCheck(TRUE) 
          ->sort('created', 'DESC')
          ->range(0, $num_of_entries); 

      } else if ($display_mode == 'date') {

        $string_start_date = $config->get('start_date');
        $start_date = strtotime($string_start_date); // Convert date to timestamp

        $metric_query = $entity_storage->getQuery()
          ->condition('type', 'health_metric')
          ->condition('created', $start_date, '>')
          ->accessCheck(TRUE)
          ->sort('created', 'DESC');
        
        $diet_query = $entity_storage->getQuery()
          ->condition('type', 'diet_entry')
          ->condition('created', $start_date, '>')
          ->accessCheck(TRUE)
          ->sort('created', 'DESC');
        
        $workout_query = $entity_storage->getQuery()
          ->condition('type', 'running_workout')
          ->condition('created', $start_date, '>')
          ->accessCheck(TRUE)
          ->sort('created', 'DESC'); 
      }

      $noninterval_metric_ids = array_values($metric_query->execute());
      $noninterval_diet_ids = array_values($diet_query->execute());
      $noninterval_workout_ids = array_values($workout_query->execute());

      $metric_ids = [];
      $diet_ids = [];
      $workout_ids = [];

      for ($i = 0; $i < count($noninterval_metric_ids); $i+=$interval) {
        $metric_ids[] = $noninterval_metric_ids[$i];
      }

      for ($i = 0; $i < count($noninterval_diet_ids); $i+=$interval) {
        $diet_ids[] = $noninterval_diet_ids[$i];
      }

      for ($i = 0; $i < count($noninterval_workout_ids); $i+=$interval) {
        $workout_ids[] = $noninterval_workout_ids[$i];
      }

      $data = [];

      if (!empty($metric_ids)) {
        $entities = $entity_storage->loadMultiple($metric_ids);
        // $data = [];
        foreach ($entities as $entity) {
          /** @var FieldableEntityInterface $entity */
          $formatted_date = \Drupal::service('date.formatter')->format(
            $entity->get('created')->value,
            'custom',
            'Y-m-d'
          );

          $data[$formatted_date] = Array(
            'weight' => $entity->get('field_weight')->value,
            'body_fat' => $entity->get('field_body_fat')->value,
            'water_content' => $entity->get('field_water_content')->value,
            'mental_energy' => $entity->get('field_mental_energy')->value,
            'physical_energy' => $entity->get('field_physical_energy')->value,
            'resting_heartrate' => $entity->get('field_resting_heartrate')->value,
            'sleep_time' => $entity->get('field_sleep_time')->value,
            'sleep_wakeups' => $entity->get('field_sleep_wake_ups')->value
          );
        }
      }

      if (!empty($diet_ids)) {
        $entities = $entity_storage->loadMultiple($diet_ids);
        // $data = [];
        foreach ($entities as $entity) {
          /** @var FieldableEntityInterface $entity */
          $formatted_date = \Drupal::service('date.formatter')->format(
            $entity->get('created')->value,
            'custom',
            'Y-m-d'
          );

          $diet_data = Array(
            'field_calories' => $entity->get('field_calories')->value,
            'field_maintenance_calories' => $entity->get('field_maintenance_calories')->value,
          );

          if (array_key_exists($formatted_date, $data)) {
            $data[$formatted_date] = array_merge($data[$formatted_date], $diet_data);
          } else {
            $data[$formatted_date] = $diet_data;
          }

        }
      }

      if (!empty($workout_ids)) {
        $entities = $entity_storage->loadMultiple($workout_ids);
        // $data = [];
        foreach ($entities as $entity) {
          /** @var FieldableEntityInterface $entity */
          $formatted_date = \Drupal::service('date.formatter')->format(
            $entity->get('created')->value,
            'custom',
            'Y-m-d'
          );

          $workout_data = Array(
            'field_distance' => $entity->get('field_distance')->value,
            'field_heart_rate' => $entity->get('field_heart_rate')->value,
            'field_run_time' => $entity->get('field_run_time')->value,
            'field_stride_length' => $entity->get('field_stride_length')->value,
            'field_strides_per_minute' => $entity->get('field_strides_per_minute')->value,
            'field_weight_added' => $entity->get('field_weight_added')->value,
          );

          if (array_key_exists($formatted_date, $data)) {
            $data[$formatted_date] = array_merge($data[$formatted_date], $workout_data);
          } else {
            $data[$formatted_date] = $workout_data;
          }
        }
      }

      // for this one I add the variables directly to the markeup instead of the Javascript. That way I can use drupal's caching
      $variables["graph_data"] = json_encode($data);
      //dpm($variables['content']['react_block']['#attached']['drupalSettings']['reactComponents'][$settingsKey] );

    }
  }
}

function react_components_theme_suggestions_block_alter(array &$suggestions, array $variables) {
  $plugin_id = $variables['elements']['#plugin_id'];

  // Various templates for different types of blocks if needed
  if ($plugin_id == 'react_block') {

    // nested deep enough for ya?
    $reactComponents = $variables['elements']['content']['react_block']['#attached']['drupalSettings']['reactComponents'];

    foreach($reactComponents as $k=>$v) {
      if ($v['componentType'] == 'results_graphs') {
        $suggestions[] = 'react_graphs_block';
      }
    }
  }
}

